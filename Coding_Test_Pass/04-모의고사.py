# 권장시간: 30분
# 권장 시간 복잡도: O(N)

"""
수포자는 수학을 포기한 사람의 줄인 표현입니다. 수포자 삼인방은 모의고사에 수학 문제를 전부 찍으려고 합니다.
수포자는 1번 문제부터 마지막 문제까지 다음과 같이 찍습니다.
- 1번 수포자가 찍는 방식: 1, 2, 3, 4, 5, 1, 2, 3, 4, 5 ...
- 2번 수포자가 찍는 방식: 2, 1, 2, 3, 2, 4, 2, 5, 2, 1, 2, 3, 2, 4, 2, 5 ...
- 3번 수포자가 찍는 방식: 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, 3, 3, 1, 1, 2, 2, 4, 4, 5, 5 ...

1번 문제부터 마지막 문제까지의 정답이 순서대로 저장된 배열 answers가 주어졌을 때 가장 많은 문제를 맞힌 사람이 누구인지 배열에 담아
반환하도록 solution() 함수를 작성하세요

- 제약조건
    - 시험은 최대 10,000문제로 구성되어있습니다.
    - 문제의 정답은 1, 2, 3, 4, 5 중 하나입니다.
    - 가장 높은 점수를 받은 사람이 여럿이라면 반환하는 값을 오름차순으로 정렬하세요
    
- 입출력 예
[1, 2, 3, 4, 5] -> [1]
[1, 3, 2, 4, 2] -> [1, 2, 3]
"""

# 입력값: 정수 배열을 받는다
# 각각의 수포자가 찍는 방식이 반복됨
# 문제의 정답이 맞으면 점수 +=1
# [1, 3, 5, 4, 5, 2, 4, 5] 라면
# [O, X, X, O, O, X, X, X] 3점
# [X, X, X, X, X, X, X, O] 1점
# [X, O, X, X, X, O, O, X] 3점
# >> [1, 3]으로 나와야 함.

# 반복되는 리스트는 나머지를 이용하면 됨.
# 현재 문제의 index가 패턴의 몇 번째 index인지 확인해야 함.
# 문제의 index가 패턴의 길이보다 클 경우 나머지를 하면 나옴.

#입력값: 정수 배열을 받는다
def solution(arr):
    # 패턴을 정렬한다
    patterns = [
        [1, 2, 3, 4, 5],
        [2, 1, 2, 3, 2, 4, 2, 5],
        [3, 3, 1, 1, 2, 2, 4, 4, 5, 5]
    ]
    # 점수를 저장할 배열을 추가한다.
    scores = [0] * 3 # 1, 2, 3
    # 각 배열을 순환한다.
    for i, answer in enumerate(arr):
    # 배열을 순환하면서 패턴과 index를 순환한다.
        for j, pattern in enumerate(patterns):
    # 해당 패턴의 값은 문제 index % 패턴 개수
            if answer == pattern[i % len(pattern)]:
    # 값이 맞으면 해당 패턴의 score index += 1
                scores[j] += 1
    # 높은 점수만 추출
    highest = []
    for i, score in enumerate(scores):
        if score == max(scores):
            highest.append(i+1)
    # 오름차순 정렬
    highest.sort()
    # 출력
    return highest

# test
print(solution([1, 3, 2, 4, 2]))

