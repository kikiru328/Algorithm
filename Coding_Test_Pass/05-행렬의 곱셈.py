# 권장시간: 40분
# 권장 시간 복잡도: O(N^3)

"""
2차원 행렬 arr1과 arr2를 입력받아 arr1에 arr2를 곱한 결과를 반환하는 solution() 함수를 완성하세요

- 제약조건
    - 행렬 arr1, arr2의 행과 열의 길이는 2이상 100이하입니다.
    - 행렬 arr1, arr2의 데이터는 -10이상 20이하인 자연수
    - 곱할 수 있는 배열만 주어짐
    
- 입출력 예
arr1                        | arr2                        | return
[[1,4], [3,2], [4,1]]       | [[3,3], [3,3]]              | [[15,15], [15,15], [15,15]]
[[2,3,2], [4,2,4], [3,1,4]] | [[5,4,3], [2,4,1], [3,1,1]] | [[22,22,11], [36,28,18], [29,20,14]]
"""

# 행렬의 곱을 그대로
# [1, 4]       [3(1), 3(2)]       [1*3(1)+4*3(3), 1*3(2)+4*3(4)]
# [3, 2]   x                  =   [3*3(1)+2*3(3), 3*3(2)+2*3(4)]
# [4, 1]       [3(3), 3(4)]       [4*3(1)+1*3(3), 4*3(2)+1*3(4)]
# arr1의 행의 갯수, arr2의 열의 갯수가 곱한 행렬의 결과

#입력값: 정수 배열 2개를 받는다
def solution(arr1, arr2):
    # 행과 열의 개수를 센다.
    r1, c1 = len(arr1), len(arr1[0])
    r2, c2 = len(arr2), len(arr2[0])
    
    # 저장할 행과 열을 구성한다. 
    result = [[0] * c2 for _ in range(r1)]
    
    # arr1의 요소를 순환한다
    # 행을 순환하고 아이템을 뽑는다.
    for i in range(r1):         
        for j in range(c2):     
            for k in range(c1): 
                result[i][j] += arr1[i][k] * arr2[k][j]
    # 저장한다.
    return result
    
print(solution([[2,3,2], [4,2,4], [3,1,4]], [[5,4,3], [2,4,1], [3,1,1]]))
    
